{
  "collection_v0": "module 0x65b247186319b2a6bf0fc894d2cf31c42f8d40922ba08d92d60788a164edbec7::collection_v0 {\n    struct COLLECTION_V0 has drop {\n        dummy_field: bool,\n    }\n    \n    struct Collection has key {\n        id: 0x2::object::UID,\n        base_type: BaseType,\n        layer_types: 0x2::vec_map::VecMap<AddTypeKey<LayerType>, LayerType>,\n        item_types: 0x2::vec_map::VecMap<AddTypeKey<ItemType>, ItemType>,\n        property_types: 0x2::vec_map::VecMap<AddTypeKey<PropertyType>, PropertyType>,\n        balance: 0x2::balance::Balance<0x2::sui::SUI>,\n    }\n    \n    struct CollectionCap has store, key {\n        id: 0x2::object::UID,\n        collection_id: 0x2::object::ID,\n    }\n    \n    struct BaseType has copy, drop, store {\n        collection_id: 0x2::object::ID,\n        name: 0x1::string::String,\n    }\n    \n    struct LayerType has copy, drop, store {\n        collection_id: 0x2::object::ID,\n        type: 0x1::string::String,\n        order: u64,\n    }\n    \n    struct ItemType has copy, drop, store {\n        collection_id: 0x2::object::ID,\n        layer_type: LayerType,\n        type: 0x1::string::String,\n        img_url: 0x1::string::String,\n    }\n    \n    struct PropertyType has copy, drop, store {\n        collection_id: 0x2::object::ID,\n        type: 0x1::string::String,\n        min: u64,\n        max: u64,\n    }\n    \n    struct Config has copy, drop, store {\n        name: 0x1::string::String,\n        content: 0x1::string::String,\n    }\n    \n    struct Base has store, key {\n        id: 0x2::object::UID,\n        type: BaseType,\n        name: 0x1::string::String,\n        img_url: 0x1::string::String,\n    }\n    \n    struct Layer has store {\n        type: LayerType,\n        socket: 0x1::option::Option<Item>,\n    }\n    \n    struct Item has store, key {\n        id: 0x2::object::UID,\n        type: ItemType,\n        properties: 0x2::vec_map::VecMap<AddTypeKey<PropertyType>, Property>,\n    }\n    \n    struct Property has store {\n        type: PropertyType,\n        value: u64,\n    }\n    \n    struct AddTypeKey<phantom T0: copy + drop + store> has copy, drop, store {\n        type: 0x1::string::String,\n    }\n    \n    struct StoreKey<T0: copy + drop + store> has copy, drop, store {\n        type: T0,\n    }\n    \n    struct ItemBagKey has copy, drop, store {\n        item_id: 0x2::object::ID,\n    }\n    \n    struct ConfigKey<phantom T0: copy + drop + store> has copy, drop, store {\n        name: 0x1::string::String,\n    }\n    \n    fun new(arg0: 0x1::string::String, arg1: &mut 0x2::tx_context::TxContext) : (Collection, CollectionCap) {\n        let v0 = 0x2::object::new(arg1);\n        let v1 = 0x2::object::uid_to_inner(&v0);\n        let v2 = BaseType{\n            collection_id : v1, \n            name          : arg0,\n        };\n        let v3 = Collection{\n            id             : v0, \n            base_type      : v2, \n            layer_types    : 0x2::vec_map::empty<AddTypeKey<LayerType>, LayerType>(), \n            item_types     : 0x2::vec_map::empty<AddTypeKey<ItemType>, ItemType>(), \n            property_types : 0x2::vec_map::empty<AddTypeKey<PropertyType>, PropertyType>(), \n            balance        : 0x2::balance::zero<0x2::sui::SUI>(),\n        };\n        let v4 = CollectionCap{\n            id            : 0x2::object::new(arg1), \n            collection_id : v1,\n        };\n        (v3, v4)\n    }\n    \n    public fun add_config_to_type<T0: copy + drop + store>(arg0: &mut Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: 0x1::string::String) {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        let v0 = ConfigKey<T0>{name: arg2};\n        let v1 = Config{\n            name    : arg2, \n            content : arg3,\n        };\n        0x2::dynamic_field::add<ConfigKey<T0>, Config>(&mut arg0.id, v0, v1);\n    }\n    \n    public fun add_item_type(arg0: &mut Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: 0x1::string::String, arg4: 0x1::string::String) {\n        let v0 = 0x2::object::id<Collection>(arg0);\n        assert!(v0 == arg1.collection_id, 1);\n        let v1 = AddTypeKey<LayerType>{type: arg2};\n        let v2 = AddTypeKey<ItemType>{type: arg3};\n        let v3 = ItemType{\n            collection_id : v0, \n            layer_type    : *0x2::vec_map::get<AddTypeKey<LayerType>, LayerType>(&arg0.layer_types, &v1), \n            type          : arg3, \n            img_url       : arg4,\n        };\n        0x2::vec_map::insert<AddTypeKey<ItemType>, ItemType>(&mut arg0.item_types, v2, v3);\n    }\n    \n    fun add_layer_to_base(arg0: &mut Base, arg1: LayerType) {\n        let v0 = Layer{\n            type   : arg1, \n            socket : 0x1::option::none<Item>(),\n        };\n        let v1 = StoreKey<LayerType>{type: arg1};\n        0x2::dynamic_field::add<StoreKey<LayerType>, Layer>(&mut arg0.id, v1, v0);\n    }\n    \n    public fun add_layer_type(arg0: &mut Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: u64) {\n        let v0 = 0x2::object::id<Collection>(arg0);\n        assert!(v0 == arg1.collection_id, 1);\n        let v1 = AddTypeKey<LayerType>{type: arg2};\n        let v2 = LayerType{\n            collection_id : v0, \n            type          : arg2, \n            order         : arg3,\n        };\n        0x2::vec_map::insert<AddTypeKey<LayerType>, LayerType>(&mut arg0.layer_types, v1, v2);\n    }\n    \n    public fun add_property_to_item(arg0: &Collection, arg1: &mut Item, arg2: Property) {\n        let v0 = AddTypeKey<ItemType>{type: arg1.type.type};\n        assert!(0x2::vec_map::contains<AddTypeKey<ItemType>, ItemType>(&arg0.item_types, &v0), 3);\n        let v1 = AddTypeKey<PropertyType>{type: arg2.type.type};\n        assert!(0x2::vec_map::contains<AddTypeKey<PropertyType>, PropertyType>(&arg0.property_types, &v1), 4);\n        let v2 = AddTypeKey<PropertyType>{type: arg2.type.type};\n        0x2::vec_map::insert<AddTypeKey<PropertyType>, Property>(&mut arg1.properties, v2, arg2);\n    }\n    \n    public fun add_property_type(arg0: &mut Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: u64, arg4: u64) {\n        let v0 = 0x2::object::id<Collection>(arg0);\n        assert!(v0 == arg1.collection_id, 1);\n        let v1 = AddTypeKey<PropertyType>{type: arg2};\n        let v2 = PropertyType{\n            collection_id : v0, \n            type          : arg2, \n            min           : arg3, \n            max           : arg4,\n        };\n        0x2::vec_map::insert<AddTypeKey<PropertyType>, PropertyType>(&mut arg0.property_types, v1, v2);\n    }\n    \n    entry fun default(arg0: 0x1::string::String, arg1: &mut 0x2::tx_context::TxContext) {\n        let (v0, v1) = new(arg0, arg1);\n        0x2::transfer::share_object<Collection>(v0);\n        0x2::transfer::transfer<CollectionCap>(v1, 0x2::tx_context::sender(arg1));\n    }\n    \n    public fun equip_item_to_base(arg0: &Collection, arg1: &mut Base, arg2: Item) {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.type.collection_id, 2);\n        let v0 = StoreKey<LayerType>{type: arg2.type.layer_type};\n        let v1 = 0x2::dynamic_field::borrow_mut<StoreKey<LayerType>, Layer>(&mut arg1.id, v0);\n        if (0x1::option::is_none<Item>(&v1.socket)) {\n            0x1::option::fill<Item>(&mut v1.socket, arg2);\n            return\n        };\n        let v2 = 0x1::option::swap<Item>(&mut v1.socket, arg2);\n        let v3 = ItemBagKey{item_id: 0x2::object::id<Item>(&v2)};\n        0x1::vector::push_back<Item>(0x2::dynamic_field::borrow_mut<ItemBagKey, vector<Item>>(&mut arg1.id, v3), v2);\n    }\n    \n    fun init(arg0: COLLECTION_V0, arg1: &mut 0x2::tx_context::TxContext) {\n        let v0 = 0x2::package::claim<COLLECTION_V0>(arg0, arg1);\n        let v1 = 0x2::display::new<Base>(&v0, arg1);\n        0x2::display::add<Base>(&mut v1, 0x1::string::utf8(b\"id\"), 0x1::string::utf8(b\"{id}\"));\n        0x2::display::add<Base>(&mut v1, 0x1::string::utf8(b\"name\"), 0x1::string::utf8(b\"{type.name}\"));\n        0x2::display::add<Base>(&mut v1, 0x1::string::utf8(b\"collection\"), 0x1::string::utf8(b\"{type.collection_id}\"));\n        0x2::display::add<Base>(&mut v1, 0x1::string::utf8(b\"img_url\"), 0x1::string::utf8(b\"{img_url}\"));\n        0x2::display::update_version<Base>(&mut v1);\n        0x2::transfer::public_transfer<0x2::display::Display<Base>>(v1, 0x2::tx_context::sender(arg1));\n        0x2::transfer::public_transfer<0x2::package::Publisher>(v0, 0x2::tx_context::sender(arg1));\n    }\n    \n    entry fun mint_and_tranfer_base(arg0: &Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: address, arg4: &mut 0x2::tx_context::TxContext) {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        0x2::transfer::transfer<Base>(new_base(arg0, arg1, arg2, arg4), arg3);\n    }\n    \n    public fun new_base(arg0: &Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: &mut 0x2::tx_context::TxContext) : Base {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        let v0 = Base{\n            id      : 0x2::object::new(arg3), \n            type    : arg0.base_type, \n            name    : arg0.base_type.name, \n            img_url : arg2,\n        };\n        let v1 = 0x2::vec_map::keys<AddTypeKey<LayerType>, LayerType>(&arg0.layer_types);\n        let v2 = &v1;\n        let v3 = 0;\n        while (v3 < 0x1::vector::length<AddTypeKey<LayerType>>(v2)) {\n            add_layer_to_base(&mut v0, *0x2::vec_map::get<AddTypeKey<LayerType>, LayerType>(&arg0.layer_types, 0x1::vector::borrow<AddTypeKey<LayerType>>(v2, v3)));\n            v3 = v3 + 1;\n        };\n        v0\n    }\n    \n    public fun new_item(arg0: &Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: &mut 0x2::tx_context::TxContext) : Item {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        let v0 = AddTypeKey<ItemType>{type: arg2};\n        Item{\n            id         : 0x2::object::new(arg3), \n            type       : *0x2::vec_map::get<AddTypeKey<ItemType>, ItemType>(&arg0.item_types, &v0), \n            properties : 0x2::vec_map::empty<AddTypeKey<PropertyType>, Property>(),\n        }\n    }\n    \n    public fun new_property(arg0: &Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: u64) : Property {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        let v0 = AddTypeKey<PropertyType>{type: arg2};\n        let v1 = 0x2::vec_map::get<AddTypeKey<PropertyType>, PropertyType>(&arg0.property_types, &v0);\n        assert!(v1.min <= arg3 && arg3 <= v1.max, 5);\n        Property{\n            type  : *v1, \n            value : arg3,\n        }\n    }\n    \n    public fun remove_item_from_bag(arg0: &mut Base, arg1: 0x2::object::ID) : Item {\n        let v0 = ItemBagKey{item_id: arg1};\n        0x2::dynamic_field::remove<ItemBagKey, Item>(&mut arg0.id, v0)\n    }\n    \n    public fun store_property(arg0: &mut Collection, arg1: &CollectionCap, arg2: Property) {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        let v0 = StoreKey<PropertyType>{type: arg2.type};\n        if (!0x2::dynamic_field::exists_<StoreKey<PropertyType>>(&arg0.id, v0)) {\n            let v1 = StoreKey<PropertyType>{type: arg2.type};\n            0x2::dynamic_field::add<StoreKey<PropertyType>, vector<Property>>(&mut arg0.id, v1, 0x1::vector::empty<Property>());\n        };\n        let v2 = StoreKey<PropertyType>{type: arg2.type};\n        0x1::vector::push_back<Property>(0x2::dynamic_field::borrow_mut<StoreKey<PropertyType>, vector<Property>>(&mut arg0.id, v2), arg2);\n    }\n    \n    public fun update_layer_type_to_base(arg0: &Collection, arg1: &mut Base) {\n        let v0 = 0x2::vec_map::keys<AddTypeKey<LayerType>, LayerType>(&arg0.layer_types);\n        let v1 = &v0;\n        let v2 = 0;\n        while (v2 < 0x1::vector::length<AddTypeKey<LayerType>>(v1)) {\n            let v3 = 0x2::vec_map::get<AddTypeKey<LayerType>, LayerType>(&arg0.layer_types, 0x1::vector::borrow<AddTypeKey<LayerType>>(v1, v2));\n            let v4 = StoreKey<LayerType>{type: *v3};\n            if (!0x2::dynamic_field::exists_<StoreKey<LayerType>>(&arg1.id, v4)) {\n                add_layer_to_base(arg1, *v3);\n            };\n            v2 = v2 + 1;\n        };\n    }\n    \n    // decompiled from Move bytecode v6\n}\n\n",
  "exclusuive": "module 0x65b247186319b2a6bf0fc894d2cf31c42f8d40922ba08d92d60788a164edbec7::exclusuive {\n    // decompiled from Move bytecode v6\n}\n\n",
  "sample_collection": "module 0x65b247186319b2a6bf0fc894d2cf31c42f8d40922ba08d92d60788a164edbec7::sample_collection {\n    struct SampleCollection has key {\n        id: 0x2::object::UID,\n        banner_url: 0x1::string::String,\n    }\n    \n    struct SampleNFT has store, key {\n        id: 0x2::object::UID,\n        collection: 0x2::object::ID,\n    }\n    \n    struct SampleLayer has store, key {\n        id: 0x2::object::UID,\n        name: 0x1::string::String,\n    }\n    \n    struct SampleItem has store, key {\n        id: 0x2::object::UID,\n        name: 0x1::string::String,\n        url: 0x1::string::String,\n        layer_name: 0x1::string::String,\n    }\n    \n    public fun add_item(arg0: &mut SampleNFT, arg1: 0x1::string::String, arg2: 0x1::string::String, arg3: 0x1::string::String, arg4: &mut 0x2::tx_context::TxContext) {\n        let v0 = SampleItem{\n            id         : 0x2::object::new(arg4), \n            name       : arg2, \n            url        : arg3, \n            layer_name : arg1,\n        };\n        0x2::dynamic_object_field::add<0x1::string::String, SampleItem>(&mut 0x2::dynamic_object_field::borrow_mut<0x1::string::String, SampleLayer>(&mut arg0.id, arg1).id, arg2, v0);\n    }\n    \n    public fun add_layer(arg0: &mut SampleNFT, arg1: 0x1::string::String, arg2: &mut 0x2::tx_context::TxContext) {\n        let v0 = SampleLayer{\n            id   : 0x2::object::new(arg2), \n            name : arg1,\n        };\n        0x2::dynamic_object_field::add<0x1::string::String, SampleLayer>(&mut arg0.id, arg1, v0);\n    }\n    \n    fun init(arg0: &mut 0x2::tx_context::TxContext) {\n        let v0 = new_collection(0x1::string::utf8(b\"https://file.notion.so/f/f/58b160c3-fe00-4852-8c42-471415797086/812a9abf-8e63-41ad-be9a-7f21053d52b8/%EB%85%B8%EC%85%98_%EC%A4%91%EA%B0%84_%EC%9D%B4%EB%AF%B8%EC%A7%80_24-2.png?table=block&id=39bc1ece-963f-424a-8dd8-3131e89408bc&spaceId=58b160c3-fe00-4852-8c42-471415797086&expirationTimestamp=1742472000000&signature=fCAaHiXd5G-ZiC-hHh0rsdqni_IUnuIUQvneONaW21g&downloadName=%EB%85%B8%EC%85%98+%EC%A4%91%EA%B0%84+%EC%9D%B4%EB%AF%B8%EC%A7%80+24-2.png\"), arg0);\n        let v1 = new_nft(&v0, arg0);\n        let v2 = 0x1::string::utf8(b\"background\");\n        let v3 = 0x1::string::utf8(b\"character\");\n        let v4 = 0x1::string::utf8(b\"cloth\");\n        add_layer(&mut v1, v2, arg0);\n        add_layer(&mut v1, v3, arg0);\n        add_layer(&mut v1, v4, arg0);\n        add_item(&mut v1, v2, 0x1::string::utf8(b\"fire\"), 0x1::string::utf8(b\"https://myyonseinft.s3.us-east-1.amazonaws.com/MAJOR/test/background.PNG\"), arg0);\n        add_item(&mut v1, v3, 0x1::string::utf8(b\"basic\"), 0x1::string::utf8(b\"https://myyonseinft.s3.us-east-1.amazonaws.com/MAJOR/test/character.png\"), arg0);\n        add_item(&mut v1, v4, 0x1::string::utf8(b\"doctor\"), 0x1::string::utf8(b\"https://myyonseinft.s3.us-east-1.amazonaws.com/MAJOR/test/clothes.PNG\"), arg0);\n        0x2::transfer::share_object<SampleCollection>(v0);\n        0x2::transfer::transfer<SampleNFT>(v1, 0x2::tx_context::sender(arg0));\n    }\n    \n    public fun new_collection(arg0: 0x1::string::String, arg1: &mut 0x2::tx_context::TxContext) : SampleCollection {\n        SampleCollection{\n            id         : 0x2::object::new(arg1), \n            banner_url : arg0,\n        }\n    }\n    \n    public fun new_nft(arg0: &SampleCollection, arg1: &mut 0x2::tx_context::TxContext) : SampleNFT {\n        SampleNFT{\n            id         : 0x2::object::new(arg1), \n            collection : 0x2::object::id<SampleCollection>(arg0),\n        }\n    }\n    \n    // decompiled from Move bytecode v6\n}\n\n",
  "collection": "module 0x65b247186319b2a6bf0fc894d2cf31c42f8d40922ba08d92d60788a164edbec7::collection {\n    struct COLLECTION has drop {\n        dummy_field: bool,\n    }\n    \n    struct Collection has store, key {\n        id: 0x2::object::UID,\n        base_type: BaseType,\n        layer_types: 0x2::vec_set::VecSet<LayerType>,\n        property_types: 0x2::vec_set::VecSet<PropertyType>,\n        ticket_types: 0x2::vec_set::VecSet<TicketType>,\n        balance: 0x2::balance::Balance<0x2::sui::SUI>,\n        version: u64,\n    }\n    \n    struct CollectionCap has store, key {\n        id: 0x2::object::UID,\n        collection_id: 0x2::object::ID,\n    }\n    \n    struct Supplyer<T0: store> has store, key {\n        id: 0x2::object::UID,\n        collection_id: 0x2::object::ID,\n        selections: vector<Selection<T0>>,\n        size: u64,\n        balance: 0x2::balance::Balance<0x2::sui::SUI>,\n    }\n    \n    struct Selection<T0: store> has store {\n        number: u64,\n        conditions: vector<Condition>,\n        price: u64,\n        product: T0,\n    }\n    \n    struct Condition has copy, drop, store {\n        ticket_type: TicketType,\n        requirement: u64,\n    }\n    \n    struct SupplyerCap has store, key {\n        id: 0x2::object::UID,\n        machine_id: 0x2::object::ID,\n    }\n    \n    struct BaseType has copy, drop, store {\n        collection_id: 0x2::object::ID,\n        type: 0x1::string::String,\n    }\n    \n    struct LayerType has copy, drop, store {\n        collection_id: 0x2::object::ID,\n        type: 0x1::string::String,\n    }\n    \n    struct PropertyType has copy, drop, store {\n        collection_id: 0x2::object::ID,\n        type: 0x1::string::String,\n    }\n    \n    struct TicketType has copy, drop, store {\n        collection_id: 0x2::object::ID,\n        type: 0x1::string::String,\n    }\n    \n    struct Config has copy, drop, store {\n        name: 0x1::string::String,\n        content: 0x1::string::String,\n    }\n    \n    struct Base has store, key {\n        id: 0x2::object::UID,\n        type: BaseType,\n        img_url: 0x1::string::String,\n    }\n    \n    struct ItemSocket has store {\n        type: LayerType,\n        socket: 0x1::option::Option<Item>,\n    }\n    \n    struct Item has store, key {\n        id: 0x2::object::UID,\n        type: LayerType,\n        item_type: 0x1::string::String,\n        img_url: 0x1::string::String,\n    }\n    \n    struct Property has store {\n        type: PropertyType,\n        value: u64,\n    }\n    \n    struct Ticket has store {\n        type: TicketType,\n    }\n    \n    struct TypeKey<phantom T0: copy + drop + store> has copy, drop, store {\n        type: 0x1::string::String,\n    }\n    \n    struct ItemBagKey has copy, drop, store {\n        type: 0x1::string::String,\n    }\n    \n    struct ConfigKey<phantom T0: copy + drop + store> has copy, drop, store {\n        type: 0x1::string::String,\n    }\n    \n    fun new(arg0: 0x1::string::String, arg1: &mut 0x2::tx_context::TxContext) : (Collection, CollectionCap) {\n        let v0 = 0x2::object::new(arg1);\n        let v1 = 0x2::object::uid_to_inner(&v0);\n        let v2 = BaseType{\n            collection_id : v1, \n            type          : arg0,\n        };\n        let v3 = Collection{\n            id             : v0, \n            base_type      : v2, \n            layer_types    : 0x2::vec_set::empty<LayerType>(), \n            property_types : 0x2::vec_set::empty<PropertyType>(), \n            ticket_types   : 0x2::vec_set::empty<TicketType>(), \n            balance        : 0x2::balance::zero<0x2::sui::SUI>(), \n            version        : 0,\n        };\n        let v4 = CollectionCap{\n            id            : 0x2::object::new(arg1), \n            collection_id : v1,\n        };\n        (v3, v4)\n    }\n    \n    public(friend) fun update_version(arg0: &mut Collection) {\n        arg0.version = arg0.version + 1;\n    }\n    \n    public fun add_config_to_type<T0: copy + drop + store>(arg0: &mut Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: 0x1::string::String, arg4: 0x1::string::String) {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        let v0 = TypeKey<T0>{type: arg2};\n        assert!(0x2::dynamic_field::exists_<TypeKey<T0>>(&arg0.id, v0), 3);\n        let v1 = ConfigKey<T0>{type: arg2};\n        let v2 = Config{\n            name    : arg3, \n            content : arg4,\n        };\n        0x2::dynamic_field::add<ConfigKey<T0>, Config>(&mut arg0.id, v1, v2);\n    }\n    \n    public fun add_layer_type(arg0: &mut Collection, arg1: &CollectionCap, arg2: 0x1::string::String) {\n        let v0 = 0x2::object::id<Collection>(arg0);\n        assert!(v0 == arg1.collection_id, 1);\n        let v1 = LayerType{\n            collection_id : v0, \n            type          : arg2,\n        };\n        0x2::vec_set::insert<LayerType>(&mut arg0.layer_types, v1);\n        let v2 = TypeKey<LayerType>{type: arg2};\n        let v3 = LayerType{\n            collection_id : v0, \n            type          : arg2,\n        };\n        0x2::dynamic_field::add<TypeKey<LayerType>, LayerType>(&mut arg0.id, v2, v3);\n        update_version(arg0);\n    }\n    \n    public fun add_property_type(arg0: &mut Collection, arg1: &CollectionCap, arg2: 0x1::string::String) {\n        let v0 = 0x2::object::id<Collection>(arg0);\n        assert!(v0 == arg1.collection_id, 1);\n        let v1 = PropertyType{\n            collection_id : v0, \n            type          : arg2,\n        };\n        0x2::vec_set::insert<PropertyType>(&mut arg0.property_types, v1);\n        let v2 = TypeKey<PropertyType>{type: arg2};\n        let v3 = PropertyType{\n            collection_id : v0, \n            type          : arg2,\n        };\n        0x2::dynamic_field::add<TypeKey<PropertyType>, PropertyType>(&mut arg0.id, v2, v3);\n        update_version(arg0);\n    }\n    \n    public fun add_ticket_type(arg0: &mut Collection, arg1: &CollectionCap, arg2: 0x1::string::String) {\n        let v0 = 0x2::object::id<Collection>(arg0);\n        assert!(v0 == arg1.collection_id, 1);\n        let v1 = TicketType{\n            collection_id : v0, \n            type          : arg2,\n        };\n        0x2::vec_set::insert<TicketType>(&mut arg0.ticket_types, v1);\n        let v2 = TypeKey<PropertyType>{type: arg2};\n        let v3 = PropertyType{\n            collection_id : v0, \n            type          : arg2,\n        };\n        0x2::dynamic_field::add<TypeKey<PropertyType>, PropertyType>(&mut arg0.id, v2, v3);\n        update_version(arg0);\n    }\n    \n    public fun attach_property_to_item(arg0: &Collection, arg1: &mut Item, arg2: Property) {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.type.collection_id, 2);\n        let v0 = TypeKey<PropertyType>{type: arg2.type.type};\n        0x2::dynamic_field::add<TypeKey<PropertyType>, Property>(&mut arg1.id, v0, arg2);\n    }\n    \n    entry fun default(arg0: 0x1::string::String, arg1: &mut 0x2::tx_context::TxContext) {\n        let (v0, v1) = new(arg0, arg1);\n        0x2::transfer::share_object<Collection>(v0);\n        0x2::transfer::transfer<CollectionCap>(v1, 0x2::tx_context::sender(arg1));\n    }\n    \n    public fun equip_item_to_base(arg0: &Collection, arg1: &mut Base, arg2: Item) {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.type.collection_id, 2);\n        let v0 = arg2.type;\n        let v1 = TypeKey<LayerType>{type: v0.type};\n        if (!0x2::dynamic_field::exists_<TypeKey<LayerType>>(&arg1.id, v1)) {\n            let v2 = TypeKey<LayerType>{type: v0.type};\n            let v3 = ItemSocket{\n                type   : v0, \n                socket : 0x1::option::none<Item>(),\n            };\n            0x2::dynamic_field::add<TypeKey<LayerType>, ItemSocket>(&mut arg1.id, v2, v3);\n        };\n        let v4 = TypeKey<LayerType>{type: v0.type};\n        let v5 = 0x2::dynamic_field::borrow_mut<TypeKey<LayerType>, ItemSocket>(&mut arg1.id, v4);\n        if (0x1::option::is_none<Item>(&v5.socket)) {\n            0x1::option::fill<Item>(&mut v5.socket, arg2);\n            return\n        };\n        let v6 = ItemBagKey{type: v0.type};\n        0x1::vector::push_back<Item>(0x2::dynamic_field::borrow_mut<ItemBagKey, vector<Item>>(&mut arg1.id, v6), 0x1::option::swap<Item>(&mut v5.socket, arg2));\n    }\n    \n    fun init(arg0: COLLECTION, arg1: &mut 0x2::tx_context::TxContext) {\n        let v0 = 0x2::package::claim<COLLECTION>(arg0, arg1);\n        let v1 = 0x2::display::new<Base>(&v0, arg1);\n        0x2::display::add<Base>(&mut v1, 0x1::string::utf8(b\"id\"), 0x1::string::utf8(b\"{id}\"));\n        0x2::display::add<Base>(&mut v1, 0x1::string::utf8(b\"name\"), 0x1::string::utf8(b\"{type.name}\"));\n        0x2::display::add<Base>(&mut v1, 0x1::string::utf8(b\"collection\"), 0x1::string::utf8(b\"{type.collection_id}\"));\n        0x2::display::add<Base>(&mut v1, 0x1::string::utf8(b\"img_url\"), 0x1::string::utf8(b\"{img_url}\"));\n        0x2::display::update_version<Base>(&mut v1);\n        0x2::transfer::public_transfer<0x2::display::Display<Base>>(v1, 0x2::tx_context::sender(arg1));\n        0x2::transfer::public_transfer<0x2::package::Publisher>(v0, 0x2::tx_context::sender(arg1));\n    }\n    \n    entry fun mint_and_tranfer_base(arg0: &Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: address, arg4: &mut 0x2::tx_context::TxContext) {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        0x2::transfer::transfer<Base>(new_base(arg0, arg1, arg2, arg4), arg3);\n    }\n    \n    public fun new_base(arg0: &Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: &mut 0x2::tx_context::TxContext) : Base {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        Base{\n            id      : 0x2::object::new(arg3), \n            type    : arg0.base_type, \n            img_url : arg2,\n        }\n    }\n    \n    public fun new_item(arg0: &Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: 0x1::string::String, arg4: 0x1::string::String, arg5: &mut 0x2::tx_context::TxContext) : Item {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        let v0 = TypeKey<LayerType>{type: arg2};\n        Item{\n            id        : 0x2::object::new(arg5), \n            type      : *0x2::dynamic_field::borrow<TypeKey<LayerType>, LayerType>(&arg0.id, v0), \n            item_type : arg3, \n            img_url   : arg4,\n        }\n    }\n    \n    public fun new_property(arg0: &Collection, arg1: &CollectionCap, arg2: 0x1::string::String, arg3: u64) : Property {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        let v0 = TypeKey<PropertyType>{type: arg2};\n        Property{\n            type  : *0x2::dynamic_field::borrow<TypeKey<PropertyType>, PropertyType>(&arg0.id, v0), \n            value : arg3,\n        }\n    }\n    \n    public fun new_ticket(arg0: &Collection, arg1: &CollectionCap, arg2: 0x1::string::String) : Ticket {\n        assert!(0x2::object::id<Collection>(arg0) == arg1.collection_id, 1);\n        let v0 = TypeKey<TicketType>{type: arg2};\n        Ticket{type: *0x2::dynamic_field::borrow<TypeKey<TicketType>, TicketType>(&arg0.id, v0)}\n    }\n    \n    public fun pop_item_from_bag(arg0: &mut Base, arg1: 0x1::string::String) : Item {\n        let v0 = ItemBagKey{type: arg1};\n        0x1::vector::pop_back<Item>(0x2::dynamic_field::borrow_mut<ItemBagKey, vector<Item>>(&mut arg0.id, v0))\n    }\n    \n    // decompiled from Move bytecode v6\n}\n\n",
  "dokpami": "module 0x65b247186319b2a6bf0fc894d2cf31c42f8d40922ba08d92d60788a164edbec7::dokpami {\n    struct DOKPAMI has drop {\n        dummy_field: bool,\n    }\n    \n    struct OldNFT has store, key {\n        id: 0x2::object::UID,\n    }\n    \n    struct Dokpami has store, key {\n        id: 0x2::object::UID,\n    }\n    \n    struct DokpamiItem<phantom T0> has store, key {\n        id: 0x2::object::UID,\n    }\n    \n    struct BackgroundLayer has drop, store {\n        dummy_field: bool,\n    }\n    \n    struct BackgroundLayer2 has drop, store {\n        dummy_field: bool,\n    }\n    \n    struct CharacterLayer has drop {\n        dummy_field: bool,\n    }\n    \n    struct StrProperty has drop {\n        dummy_field: bool,\n    }\n    \n    struct IntProperty has drop {\n        dummy_field: bool,\n    }\n    \n    struct FireBackground has store, key {\n        id: 0x2::object::UID,\n    }\n    \n    struct SnowBackground has store, key {\n        id: 0x2::object::UID,\n    }\n    \n    struct RainBackground has store, key {\n        id: 0x2::object::UID,\n    }\n    \n    struct Character1 has store, key {\n        id: 0x2::object::UID,\n    }\n    \n    struct Character2 has store, key {\n        id: 0x2::object::UID,\n    }\n    \n    struct LayerConfig has drop, store {\n        description: 0x1::string::String,\n    }\n    \n    struct ItemConfig has drop, store {\n        description: 0x1::string::String,\n        sub_descir: 0x1::string::String,\n    }\n    \n    struct PropertyConfig has drop, store {\n        description: 0x1::string::String,\n        sub_descir: 0x1::string::String,\n    }\n    \n    public fun new(arg0: &mut 0x2::tx_context::TxContext) : Dokpami {\n        Dokpami{id: 0x2::object::new(arg0)}\n    }\n    \n    public fun default(arg0: &mut 0x2::tx_context::TxContext) {\n        let v0 = Dokpami{id: 0x2::object::new(arg0)};\n        0x2::transfer::transfer<Dokpami>(v0, 0x2::tx_context::sender(arg0));\n    }\n    \n    fun init(arg0: DOKPAMI, arg1: &mut 0x2::tx_context::TxContext) {\n        let v0 = 0x2::package::claim<DOKPAMI>(arg0, arg1);\n        let (v1, v2) = 0x65b247186319b2a6bf0fc894d2cf31c42f8d40922ba08d92d60788a164edbec7::membership_policy::new<Dokpami>(&v0, arg1);\n        0x2::transfer::public_share_object<0x65b247186319b2a6bf0fc894d2cf31c42f8d40922ba08d92d60788a164edbec7::membership_policy::MembershipPolicy<Dokpami>>(v1);\n        0x2::transfer::public_transfer<0x65b247186319b2a6bf0fc894d2cf31c42f8d40922ba08d92d60788a164edbec7::membership_policy::MembershipPolicyCap<Dokpami>>(v2, 0x2::tx_context::sender(arg1));\n        0x2::transfer::public_transfer<0x2::package::Publisher>(v0, 0x2::tx_context::sender(arg1));\n    }\n    \n    // decompiled from Move bytecode v6\n}\n\n",
  "membership_policy": "module 0x65b247186319b2a6bf0fc894d2cf31c42f8d40922ba08d92d60788a164edbec7::membership_policy {\n    struct MembershipPolicy<phantom T0: key> has store, key {\n        id: 0x2::object::UID,\n        balance: 0x2::balance::Balance<0x2::sui::SUI>,\n        layer_types: 0x2::vec_set::VecSet<0x1::type_name::TypeName>,\n        version: u16,\n    }\n    \n    struct MembershipPolicyCap<phantom T0: key> has store, key {\n        id: 0x2::object::UID,\n        policy_id: 0x2::object::ID,\n    }\n    \n    struct VendingMachine<phantom T0: key> has store, key {\n        id: 0x2::object::UID,\n        policy_id: 0x2::object::ID,\n        selections: vector<Selection>,\n        size: u64,\n        balance: 0x2::balance::Balance<0x2::sui::SUI>,\n    }\n    \n    struct VendingMachineCap<phantom T0: key> has store, key {\n        id: 0x2::object::UID,\n        machine_id: 0x2::object::ID,\n    }\n    \n    struct Selection has store {\n        number: u64,\n        conditions: vector<Condition>,\n        price: u64,\n        product: 0x1::type_name::TypeName,\n    }\n    \n    struct Condition has copy, drop, store {\n        ticket_type: 0x1::type_name::TypeName,\n        requirement: u64,\n    }\n    \n    struct SelectRequest<phantom T0: key> {\n        machine_id: 0x2::object::ID,\n        selection_number: u64,\n        paid: u64,\n        receipts: 0x2::vec_map::VecMap<0x1::type_name::TypeName, u64>,\n    }\n    \n    struct MembershipKey has copy, drop, store {\n        dummy_field: bool,\n    }\n    \n    struct LayerKey<phantom T0: drop> has copy, drop, store {\n        dummy_field: bool,\n    }\n    \n    struct ItemBagKey<phantom T0: drop> has copy, drop, store {\n        dummy_field: bool,\n    }\n    \n    struct PropertyKey<phantom T0: drop> has copy, drop, store {\n        dummy_field: bool,\n    }\n    \n    struct TicketKey<phantom T0: drop> has copy, drop, store {\n        dummy_field: bool,\n    }\n    \n    struct ConfigKey has copy, drop, store {\n        dummy_field: bool,\n    }\n    \n    struct ProductKey has copy, drop, store {\n        selection_number: u64,\n    }\n    \n    struct Membership<phantom T0: key> has store, key {\n        id: 0x2::object::UID,\n        policy_id: 0x2::object::ID,\n    }\n    \n    struct ItemSocket<phantom T0: drop, T1: copy + drop + store> has store {\n        socket: 0x1::option::Option<Item<T0>>,\n        cfg: T1,\n    }\n    \n    struct Item<phantom T0: drop> has store, key {\n        id: 0x2::object::UID,\n        item_type: 0x1::string::String,\n        img_url: 0x1::string::String,\n    }\n    \n    struct Property<phantom T0: drop> has store {\n        value: u64,\n    }\n    \n    struct Ticket<phantom T0: drop> has store, key {\n        id: 0x2::object::UID,\n    }\n    \n    public fun new<T0: key>(arg0: &0x2::package::Publisher, arg1: &mut 0x2::tx_context::TxContext) : (MembershipPolicy<T0>, MembershipPolicyCap<T0>) {\n        assert!(0x2::package::from_package<T0>(arg0), 0);\n        let v0 = 0x2::object::new(arg1);\n        let v1 = MembershipPolicy<T0>{\n            id          : v0, \n            balance     : 0x2::balance::zero<0x2::sui::SUI>(), \n            layer_types : 0x2::vec_set::empty<0x1::type_name::TypeName>(), \n            version     : 0,\n        };\n        let v2 = MembershipPolicyCap<T0>{\n            id        : 0x2::object::new(arg1), \n            policy_id : 0x2::object::uid_to_inner(&v0),\n        };\n        (v1, v2)\n    }\n    \n    public fun add_balance_to_machine<T0: key>(arg0: &mut VendingMachine<T0>, arg1: &mut SelectRequest<T0>, arg2: 0x2::coin::Coin<0x2::sui::SUI>) {\n        assert!(0x2::object::id<VendingMachine<T0>>(arg0) == arg1.machine_id, 106);\n        arg1.paid = arg1.paid + 0x2::coin::value<0x2::sui::SUI>(&arg2);\n        0x2::balance::join<0x2::sui::SUI>(&mut arg0.balance, 0x2::coin::into_balance<0x2::sui::SUI>(arg2));\n    }\n    \n    public fun add_condition_to_selection<T0: drop>(arg0: &mut Selection, arg1: u64) {\n        let v0 = Condition{\n            ticket_type : 0x1::type_name::get<T0>(), \n            requirement : arg1,\n        };\n        0x1::vector::push_back<Condition>(&mut arg0.conditions, v0);\n    }\n    \n    public fun add_item_to_membership<T0: key, T1: drop, T2: copy + drop + store>(arg0: &mut Membership<T0>, arg1: Item<T1>, arg2: &MembershipPolicy<T0>) {\n        assert!(has_layer<T0, T1>(arg2), 102);\n        let v0 = ItemBagKey<T1>{dummy_field: false};\n        if (!0x2::dynamic_field::exists_<ItemBagKey<T1>>(&arg0.id, v0)) {\n            let v1 = ItemBagKey<T1>{dummy_field: false};\n            0x2::dynamic_field::add<ItemBagKey<T1>, vector<Item<T1>>>(&mut arg0.id, v1, 0x1::vector::empty<Item<T1>>());\n        };\n        let v2 = LayerKey<T1>{dummy_field: false};\n        if (!0x2::dynamic_field::exists_<LayerKey<T1>>(&arg0.id, v2)) {\n            let v3 = LayerKey<T1>{dummy_field: false};\n            let v4 = ItemSocket<T1, T2>{\n                socket : 0x1::option::none<Item<T1>>(), \n                cfg    : *0x2::dynamic_field::borrow<LayerKey<T1>, T2>(&arg2.id, v3),\n            };\n            let v5 = LayerKey<T1>{dummy_field: false};\n            0x2::dynamic_field::add<LayerKey<T1>, ItemSocket<T1, T2>>(&mut arg0.id, v5, v4);\n        };\n        let v6 = LayerKey<T1>{dummy_field: false};\n        let v7 = 0x2::dynamic_field::remove<LayerKey<T1>, ItemSocket<T1, T2>>(&mut arg0.id, v6);\n        if (0x1::option::is_some<Item<T1>>(&v7.socket)) {\n            let v8 = ItemBagKey<T1>{dummy_field: false};\n            0x1::vector::push_back<Item<T1>>(0x2::dynamic_field::borrow_mut<ItemBagKey<T1>, vector<Item<T1>>>(&mut arg0.id, v8), 0x1::option::extract<Item<T1>>(&mut v7.socket));\n        };\n        0x1::option::fill<Item<T1>>(&mut v7.socket, arg1);\n        let v9 = LayerKey<T1>{dummy_field: false};\n        0x2::dynamic_field::add<LayerKey<T1>, ItemSocket<T1, T2>>(&mut arg0.id, v9, v7);\n    }\n    \n    public fun add_layer_type<T0: key, T1: drop, T2: copy + drop + store>(arg0: T1, arg1: &mut MembershipPolicy<T0>, arg2: &MembershipPolicyCap<T0>, arg3: T2) {\n        assert!(0x2::object::id<MembershipPolicy<T0>>(arg1) == arg2.policy_id, 100);\n        assert!(!has_layer<T0, T1>(arg1), 101);\n        0x2::vec_set::insert<0x1::type_name::TypeName>(&mut arg1.layer_types, 0x1::type_name::get<T1>());\n        let v0 = LayerKey<T1>{dummy_field: false};\n        0x2::dynamic_field::add<LayerKey<T1>, T2>(&mut arg1.id, v0, arg3);\n        update_version_policy<T0>(arg1);\n    }\n    \n    public fun add_membership<T0: key>(arg0: &mut 0x2::object::UID, arg1: &MembershipPolicy<T0>, arg2: &mut 0x2::tx_context::TxContext) {\n        let v0 = Membership<T0>{\n            id        : 0x2::object::new(arg2), \n            policy_id : 0x2::object::id<MembershipPolicy<T0>>(arg1),\n        };\n        let v1 = MembershipKey{dummy_field: false};\n        0x2::dynamic_field::add<MembershipKey, Membership<T0>>(arg0, v1, v0);\n    }\n    \n    public fun add_product_to_machine<T0: key, T1: store>(arg0: &mut VendingMachine<T0>, arg1: &VendingMachineCap<T0>, arg2: u64, arg3: T1) {\n        assert!(0x2::object::id<VendingMachine<T0>>(arg0) == arg1.machine_id, 100);\n        0x1::vector::borrow<Selection>(&arg0.selections, arg2);\n        let v0 = ProductKey{selection_number: arg2};\n        0x1::vector::push_back<T1>(0x2::dynamic_field::borrow_mut<ProductKey, vector<T1>>(&mut arg0.id, v0), arg3);\n    }\n    \n    public fun add_property_type<T0: key, T1: drop, T2: copy + drop + store>(arg0: T1, arg1: &mut MembershipPolicy<T0>, arg2: &MembershipPolicyCap<T0>, arg3: T2) {\n        assert!(0x2::object::id<MembershipPolicy<T0>>(arg1) == arg2.policy_id, 100);\n        assert!(!has_property<T0, T1>(arg1), 101);\n        let v0 = LayerKey<T1>{dummy_field: false};\n        0x2::dynamic_field::add<LayerKey<T1>, T2>(&mut arg1.id, v0, arg3);\n        update_version_policy<T0>(arg1);\n    }\n    \n    public fun add_selection_to_machine<T0: key, T1: store>(arg0: &mut VendingMachine<T0>, arg1: &VendingMachineCap<T0>, arg2: u64) {\n        assert!(0x2::object::id<VendingMachine<T0>>(arg0) == arg1.machine_id, 100);\n        let v0 = Selection{\n            number     : 0x1::vector::length<Selection>(&arg0.selections), \n            conditions : 0x1::vector::empty<Condition>(), \n            price      : arg2, \n            product    : 0x1::type_name::get<T1>(),\n        };\n        let v1 = ProductKey{selection_number: 0x1::vector::length<Selection>(&arg0.selections)};\n        0x2::dynamic_field::add<ProductKey, vector<T1>>(&mut arg0.id, v1, 0x1::vector::empty<T1>());\n        0x1::vector::push_back<Selection>(&mut arg0.selections, v0);\n        arg0.size = 0x1::vector::length<Selection>(&arg0.selections);\n    }\n    \n    public fun add_ticket_to_membership<T0: key, T1: drop>(arg0: &mut Membership<T0>, arg1: Ticket<T1>) {\n        let v0 = TicketKey<T1>{dummy_field: false};\n        if (!0x2::dynamic_field::exists_<TicketKey<T1>>(&arg0.id, v0)) {\n            let v1 = TicketKey<T1>{dummy_field: false};\n            0x2::dynamic_field::add<TicketKey<T1>, vector<Ticket<T1>>>(&mut arg0.id, v1, 0x1::vector::empty<Ticket<T1>>());\n        };\n        let v2 = TicketKey<T1>{dummy_field: false};\n        0x1::vector::push_back<Ticket<T1>>(0x2::dynamic_field::borrow_mut<TicketKey<T1>, vector<Ticket<T1>>>(&mut arg0.id, v2), arg1);\n    }\n    \n    public fun attatch_property_to_item<T0: drop, T1: drop>(arg0: &mut Item<T0>, arg1: Property<T1>) {\n        let v0 = PropertyKey<T1>{dummy_field: false};\n        0x2::dynamic_field::add<PropertyKey<T1>, Property<T1>>(&mut arg0.id, v0, arg1);\n    }\n    \n    public fun borrow_membership<T0: key>(arg0: &0x2::object::UID, arg1: &MembershipPolicy<T0>) : &Membership<T0> {\n        let v0 = MembershipKey{dummy_field: false};\n        let v1 = 0x2::dynamic_field::borrow<MembershipKey, Membership<T0>>(arg0, v0);\n        assert!(0x2::object::id<MembershipPolicy<T0>>(arg1) == v1.policy_id, 104);\n        v1\n    }\n    \n    public fun borrow_mut_membership<T0: key>(arg0: &mut 0x2::object::UID, arg1: &MembershipPolicy<T0>) : &mut Membership<T0> {\n        let v0 = MembershipKey{dummy_field: false};\n        let v1 = 0x2::dynamic_field::borrow_mut<MembershipKey, Membership<T0>>(arg0, v0);\n        assert!(0x2::object::id<MembershipPolicy<T0>>(arg1) == v1.policy_id, 104);\n        v1\n    }\n    \n    public fun borrow_mut_selection<T0: key>(arg0: &mut VendingMachine<T0>, arg1: &VendingMachineCap<T0>, arg2: u64) : &mut Selection {\n        assert!(0x2::object::id<VendingMachine<T0>>(arg0) == arg1.machine_id, 100);\n        0x1::vector::borrow_mut<Selection>(&mut arg0.selections, arg2)\n    }\n    \n    public fun borrow_selection<T0: key>(arg0: &mut VendingMachine<T0>, arg1: &VendingMachineCap<T0>, arg2: u64) : &Selection {\n        assert!(0x2::object::id<VendingMachine<T0>>(arg0) == arg1.machine_id, 100);\n        0x1::vector::borrow<Selection>(&arg0.selections, arg2)\n    }\n    \n    public fun burn_ticket<T0: key, T1: drop>(arg0: T1, arg1: &mut VendingMachine<T0>, arg2: &mut SelectRequest<T0>, arg3: Ticket<T1>) {\n        assert!(0x2::object::id<VendingMachine<T0>>(arg1) == arg2.machine_id, 106);\n        let Ticket { id: v0 } = arg3;\n        0x2::object::delete(v0);\n        let v1 = 0x1::type_name::get<T1>();\n        let (v2, v3) = 0x2::vec_map::remove<0x1::type_name::TypeName, u64>(&mut arg2.receipts, &v1);\n        0x2::vec_map::insert<0x1::type_name::TypeName, u64>(&mut arg2.receipts, v2, v3 + 1);\n    }\n    \n    public fun confirm_request<T0: key, T1: store>(arg0: &mut VendingMachine<T0>, arg1: SelectRequest<T0>) : (0x2::object::ID, u64, T1) {\n        let SelectRequest {\n            machine_id       : v0,\n            selection_number : v1,\n            paid             : v2,\n            receipts         : v3,\n        } = arg1;\n        let v4 = v3;\n        let v5 = 0x1::vector::borrow<Selection>(&arg0.selections, v1);\n        assert!(v5.price == v2, 107);\n        let v6 = v5.conditions;\n        let v7 = 0x1::vector::length<Condition>(&v5.conditions);\n        while (v7 > 0) {\n            let v8 = 0x1::vector::pop_back<Condition>(&mut v6);\n            let v9 = v8.ticket_type;\n            assert!(*0x2::vec_map::get<0x1::type_name::TypeName, u64>(&v4, &v9) == v8.requirement, 105);\n            v7 = v7 - 1;\n        };\n        let v10 = ProductKey{selection_number: v1};\n        (v0, v2, 0x1::vector::pop_back<T1>(0x2::dynamic_field::borrow_mut<ProductKey, vector<T1>>(&mut arg0.id, v10)))\n    }\n    \n    public(friend) fun get_struct_name(arg0: 0x1::type_name::TypeName) : 0x1::string::String {\n        let v0 = 0x1::ascii::into_bytes(0x1::type_name::into_string(arg0));\n        let v1 = b\"\";\n        loop {\n            let v2 = 0x1::vector::pop_back<u8>(&mut v0);\n            if (v2 == 60 || v2 == 62) {\n                continue\n            };\n            if (v2 != 58) {\n                0x1::vector::push_back<u8>(&mut v1, v2);\n            } else {\n                break\n            };\n        };\n        0x1::vector::reverse<u8>(&mut v1);\n        0x1::string::utf8(v1)\n    }\n    \n    public fun has_layer<T0: key, T1: drop>(arg0: &MembershipPolicy<T0>) : bool {\n        let v0 = LayerKey<T1>{dummy_field: false};\n        0x2::dynamic_field::exists_<LayerKey<T1>>(&arg0.id, v0)\n    }\n    \n    public fun has_property<T0: key, T1: drop>(arg0: &MembershipPolicy<T0>) : bool {\n        let v0 = PropertyKey<T1>{dummy_field: false};\n        0x2::dynamic_field::exists_<PropertyKey<T1>>(&arg0.id, v0)\n    }\n    \n    public fun new_item<T0: drop, T1: copy + drop + store>(arg0: T0, arg1: 0x1::string::String, arg2: 0x1::string::String, arg3: T1, arg4: &mut 0x2::tx_context::TxContext) : Item<T0> {\n        let v0 = Item<T0>{\n            id        : 0x2::object::new(arg4), \n            item_type : arg1, \n            img_url   : arg2,\n        };\n        let v1 = ConfigKey{dummy_field: false};\n        0x2::dynamic_field::add<ConfigKey, T1>(&mut v0.id, v1, arg3);\n        v0\n    }\n    \n    public fun new_property_value<T0: drop>(arg0: T0, arg1: u64) : Property<T0> {\n        Property<T0>{value: arg1}\n    }\n    \n    public fun new_request<T0: key>(arg0: &VendingMachine<T0>, arg1: u64) : SelectRequest<T0> {\n        SelectRequest<T0>{\n            machine_id       : 0x2::object::id<VendingMachine<T0>>(arg0), \n            selection_number : arg1, \n            paid             : 0, \n            receipts         : 0x2::vec_map::empty<0x1::type_name::TypeName, u64>(),\n        }\n    }\n    \n    public fun new_ticket<T0: drop>(arg0: T0, arg1: &mut 0x2::tx_context::TxContext) : Ticket<T0> {\n        Ticket<T0>{id: 0x2::object::new(arg1)}\n    }\n    \n    public fun new_vending_machine<T0: key>(arg0: &MembershipPolicy<T0>, arg1: &MembershipPolicyCap<T0>, arg2: &mut 0x2::tx_context::TxContext) : (VendingMachine<T0>, VendingMachineCap<T0>) {\n        assert!(0x2::object::id<MembershipPolicy<T0>>(arg0) == arg1.policy_id, 100);\n        let v0 = 0x2::object::new(arg2);\n        let v1 = VendingMachine<T0>{\n            id         : v0, \n            policy_id  : 0x2::object::id<MembershipPolicy<T0>>(arg0), \n            selections : 0x1::vector::empty<Selection>(), \n            size       : 0, \n            balance    : 0x2::balance::zero<0x2::sui::SUI>(),\n        };\n        let v2 = VendingMachineCap<T0>{\n            id         : 0x2::object::new(arg2), \n            machine_id : 0x2::object::uid_to_inner(&v0),\n        };\n        (v1, v2)\n    }\n    \n    public fun pop_ticket_from_membership<T0: key, T1: drop>(arg0: &mut Membership<T0>) : Ticket<T1> {\n        let v0 = TicketKey<T1>{dummy_field: false};\n        0x1::vector::pop_back<Ticket<T1>>(0x2::dynamic_field::borrow_mut<TicketKey<T1>, vector<Ticket<T1>>>(&mut arg0.id, v0))\n    }\n    \n    public(friend) fun update_version_policy<T0: key>(arg0: &mut MembershipPolicy<T0>) {\n        arg0.version = arg0.version + 1;\n    }\n    \n    // decompiled from Move bytecode v6\n}\n\n"
}
